{"version":3,"sources":["LoadButton.module.scss","constants.ts","util.ts","charts/LineChart.tsx","Editor.tsx","services/loaders/GPXLoader.ts","LoadButton.tsx","SaveButton.tsx","App.tsx","index.tsx"],"names":["module","exports","STREAM_TYPES","COLORS","ACTIVITY_TYPE","readFileAsString","file","Promise","resolve","reject","reader","FileReader","onload","result","onerror","readAsText","LineChart","streams","timestamps","uniq","flatMap","stream","data","map","d","timestamp","firstTimestamp","Math","min","t","Object","fromEntries","si","value","find","undefined","filter","s","style","width","height","ResponsiveContainer","margin","top","right","left","bottom","CartesianGrid","strokeDasharray","XAxis","dataKey","type","domain","dataMax","ceil","allowDecimals","tickFormatter","YAxis","Tooltip","labelFormatter","minutesInput","totalSeconds","floor","hours","minutes","seconds","toString","padStart","formatTime","formatter","round","Legend","Line","isAnimationActive","dot","stroke","length","name","Editor","gpxData","useState","setName","setType","Card","sx","mb","CardContent","TextField","onChange","e","target","size","Select","entries","typeId","MenuItem","filteredStreams","Typography","variant","gutterBottom","component","streamNames","cadence","elevation","heartrate","power","coordinate","options","arrayMode","ignoreAttributes","attributeNamePrefix","parseAttributeValue","loadGPXFile","a","fileData","xml","parseXml","trk","gpx","trackPoints","trkseg","trkpt","getStream","getCoordinateFromTrackPoint","getCadenceFromTrackPoint","getElevationFromTrackPoint","getHeartRateFromTrackPoint","getPowerFromTrackPoint","getter","range","i","trackPoint","getUnixTime","parseISO","time","extensions","lat","lon","ele","LoadButton","addGPXData","inputRef","useRef","handleFileChange","event","files","parseFile","console","error","accept","ref","className","styles","Input","Button","onClick","current","click","endsWith","Error","SaveButton","sortBy","obj","join","metadata","formatISO","builder","create","end","pretty","createXML","FileSaver","saveAs","Blob","slugify","App","setGPXData","useCallback","prevData","AppBar","position","Toolbar","Container","ReactDOM","render","StrictMode","CssBaseline","document","getElementById"],"mappings":"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","file":"static/js/main.c0b4034e.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"Input\":\"LoadButton_Input__2BOF0\"};","import { StreamType } from \"./types\";\n\nexport const STREAM_TYPES: StreamType[] = [\n  \"heartrate\",\n  \"power\",\n  \"cadence\",\n  \"elevation\",\n  \"coordinate\",\n];\n\nexport const COLORS = [\n  \"#F44336\",\n  \"#9C27B0\",\n  \"#3F51B5\",\n  \"#03A9F4\",\n  \"#009688\",\n  \"#8BC34A\",\n  \"#FFEB3B\",\n  \"#FF9800\",\n  \"#795548\",\n  \"#607D8B\",\n  \"#E91E63\",\n  \"#673AB7\",\n  \"#2196F3\",\n  \"#00BCD4\",\n  \"#4CAF50\",\n  \"#CDDC39\",\n  \"#FFC107\",\n  \"#FF5722\",\n  \"#9E9E9E\",\n];\n\nexport const ACTIVITY_TYPE = {\n  0: \"Activity\",\n  1: \"Ride\",\n  2: \"Alpine Ski\",\n  3: \"Backcountry Ski\",\n  4: \"Hike\",\n  5: \"Ice Skate\",\n  6: \"Inline Skate\",\n  7: \"Nordic Ski\",\n  8: \"Roller Ski\",\n  9: \"Run\",\n  10: \"Walk\",\n  11: \"Workout\",\n  12: \"Snowboard\",\n  13: \"Snowshoe\",\n  14: \"Kitesurf\",\n  15: \"Windsurf\",\n  16: \"Swim\",\n  17: \"Virtual Ride\",\n  18: \"E-Bike Ride\",\n  19: \"Velomobile\",\n  21: \"Canoe\",\n  22: \"Kayaking\",\n  23: \"Rowing\",\n  24: \"Stand Up Paddling\",\n  25: \"Surfing\",\n  26: \"Crossfit\",\n  27: \"Elliptical\",\n  28: \"Rock Climb\",\n  29: \"Stair-Stepper\",\n  30: \"Weight Training\",\n  31: \"Yoga\",\n  51: \"Handcycle\",\n  52: \"Wheelchair\",\n  53: \"Virtual Run\",\n};\n","export function readFileAsString(file: File): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => resolve(reader.result as string);\n    reader.onerror = reject;\n    reader.readAsText(file);\n  });\n}\n\nexport function formatTime(minutesInput: number): string {\n  const totalSeconds = Math.floor(minutesInput * 60);\n\n  const hours = Math.floor(totalSeconds / 3600);\n  const minutes = Math.floor((totalSeconds - hours * 3600) / 60);\n  const seconds = totalSeconds - hours * 3600 - minutes * 60;\n\n  if (hours > 0) {\n    return `${hours}:${minutes.toString().padStart(2, \"0\")}:${seconds\n      .toString()\n      .padStart(2, \"0\")}h`;\n  } else if (minutes > 0) {\n    return `${minutes}:${seconds.toString().padStart(2, \"0\")}min`;\n  } else {\n    return `${seconds}s`;\n  }\n}\n","import {\n  CartesianGrid,\n  Legend,\n  Line,\n  LineChart as LineChartComponent,\n  ResponsiveContainer,\n  Tooltip,\n  XAxis,\n  YAxis,\n} from \"recharts\";\nimport { COLORS } from \"../constants\";\nimport { Stream } from \"../types\";\nimport uniq from \"lodash/uniq\";\nimport { formatTime } from \"../util\";\n\ninterface Props {\n  streams: (Stream & { name: string })[];\n}\n\nexport function LineChart({ streams }: Props) {\n  const timestamps = uniq(\n    streams.flatMap((stream) => stream.data.map((d) => d.timestamp))\n  );\n\n  const firstTimestamp = Math.min(...timestamps);\n\n  const data = timestamps.map((t) => ({\n    timestamp: (t - firstTimestamp) / 60,\n\n    ...Object.fromEntries(\n      streams\n        .map((stream, si) => {\n          // @ts-ignore\n          const value = stream.data.find((d) => d.timestamp === t)?.value;\n          if (value !== undefined) {\n            return [`s${si}`, value];\n          }\n\n          return null;\n        })\n        .filter((s): s is any[] => s !== null)\n    ),\n  }));\n\n  return (\n    <div style={{ width: \"100%\", height: 300 }}>\n      <ResponsiveContainer>\n        <LineChartComponent\n          data={data}\n          margin={{\n            top: 5,\n            right: 30,\n            left: 20,\n            bottom: 5,\n          }}\n        >\n          <CartesianGrid strokeDasharray=\"3 3\" />\n          <XAxis\n            dataKey=\"timestamp\"\n            type=\"number\"\n            domain={[\"dataMin\", (dataMax: number) => Math.ceil(dataMax)]}\n            allowDecimals={false}\n            tickFormatter={(timestamp) => `${timestamp}min`}\n          />\n          <YAxis\n            domain={[\"dataMin\", \"dataMax\"]}\n            type=\"number\"\n            allowDecimals={false}\n          />\n          <Tooltip\n            labelFormatter={(value: number) => formatTime(value)}\n            formatter={(value: number) => Math.round(value)}\n          />\n          <Legend />\n          {streams.map((s, si) => (\n            <Line\n              key={si}\n              type=\"monotone\"\n              dataKey={`s${si}`}\n              isAnimationActive={false}\n              dot={false}\n              stroke={COLORS[si % COLORS.length]}\n              name={s.name}\n            />\n          ))}\n        </LineChartComponent>\n      </ResponsiveContainer>\n    </div>\n  );\n}\n","import {\n  Card,\n  CardContent,\n  MenuItem,\n  Select,\n  TextField,\n  Typography,\n} from \"@mui/material\";\nimport React, { Fragment, useState } from \"react\";\nimport { LineChart } from \"./charts/LineChart\";\nimport { ACTIVITY_TYPE, STREAM_TYPES } from \"./constants\";\nimport { GPXData, Stream, StreamType } from \"./types\";\n\ninterface Props {\n  gpxData: GPXData[];\n}\n\nexport function Editor({ gpxData }: Props) {\n  const [name, setName] = useState(gpxData[0].name);\n  const [type, setType] = useState(gpxData[0].type);\n\n  return (\n    <>\n      <Card sx={{ mb: 3 }}>\n        <CardContent>\n          <TextField\n            value={name}\n            onChange={(e) => setName(e.target.value)}\n            size=\"small\"\n          />\n          <Select\n            value={type}\n            onChange={(e) => setType(e.target.value as number)}\n            size=\"small\"\n          >\n            {Object.entries(ACTIVITY_TYPE).map(([typeId, type]) => (\n              <MenuItem key={typeId} value={typeId}>\n                {type}\n              </MenuItem>\n            ))}\n          </Select>\n        </CardContent>\n      </Card>\n\n      {STREAM_TYPES.filter((t) => t !== \"coordinate\").map((type) => {\n        const filteredStreams = gpxData\n          .map((data) => ({ ...data[type], name: data.name }))\n          .filter(\n            (stream): stream is Stream & { name: string } =>\n              stream !== undefined\n          );\n\n        if (filteredStreams.length === 0) {\n          return null;\n        }\n\n        return (\n          <Card key={type} sx={{ mb: 3 }}>\n            <CardContent>\n              <Typography variant=\"h5\" gutterBottom component=\"div\">\n                {streamNames[type]}\n              </Typography>\n              <LineChart streams={filteredStreams} />\n            </CardContent>\n          </Card>\n        );\n      })}\n    </>\n  );\n}\n\nconst streamNames: { [type in StreamType]: string } = {\n  cadence: \"Cadence\",\n  elevation: \"elevation\",\n  heartrate: \"Heart Rate\",\n  power: \"Power\",\n  coordinate: \"Map\",\n};\n","import { BaseStream, GPXData, StreamType } from \"../../types\";\nimport { readFileAsString } from \"../../util\";\nimport { parse as parseXml, X2jOptionsOptional } from \"fast-xml-parser\";\nimport parseISO from \"date-fns/parseISO\";\nimport getUnixTime from \"date-fns/getUnixTime\";\nimport range from \"lodash/range\";\n\nconst options: X2jOptionsOptional = {\n  arrayMode: true,\n  ignoreAttributes: false,\n  attributeNamePrefix: \"\",\n  parseAttributeValue: true,\n};\n\nexport async function loadGPXFile(file: File): Promise<GPXData> {\n  const fileData = await readFileAsString(file);\n  const xml = parseXml(fileData, options);\n\n  const trk = xml.gpx[0].trk[0];\n  const trackPoints: any[] = trk.trkseg[0].trkpt;\n\n  return {\n    name: trk.name,\n    type: trk.type,\n    coordinate: getStream<[number, number], \"coordinate\">(\n      trackPoints,\n      \"coordinate\",\n      getCoordinateFromTrackPoint\n    ),\n    cadence: getStream<number, \"cadence\">(\n      trackPoints,\n      \"cadence\",\n      getCadenceFromTrackPoint\n    ),\n    elevation: getStream<number, \"elevation\">(\n      trackPoints,\n      \"elevation\",\n      getElevationFromTrackPoint\n    ),\n    heartrate: getStream<number, \"heartrate\">(\n      trackPoints,\n      \"heartrate\",\n      getHeartRateFromTrackPoint\n    ),\n    power: getStream<number, \"power\">(\n      trackPoints,\n      \"power\",\n      getPowerFromTrackPoint\n    ),\n  };\n}\n\nfunction getStream<StreamValue, Type extends StreamType, TrackPoint = any>(\n  trackPoints: TrackPoint[],\n  type: Type,\n  getter: (trackPoint: TrackPoint) => any\n): BaseStream<Type, StreamValue> {\n  return {\n    type: type,\n    data: range(0, trackPoints.length).map((i) => ({\n      timestamp: getTimestampFromTrackPoint(trackPoints[i]),\n      value: getter(trackPoints[i]),\n    })),\n  };\n}\n\nfunction getTimestampFromTrackPoint(trackPoint: any): number {\n  return getUnixTime(parseISO(trackPoint.time));\n}\n\nfunction getHeartRateFromTrackPoint(trackPoint: any): number | null {\n  return (\n    trackPoint.extensions?.[0]?.[\"gpxtpx:TrackPointExtension\"]?.[0]?.[\n      \"gpxtpx:hr\"\n    ] ?? null\n  );\n}\n\nfunction getCadenceFromTrackPoint(trackPoint: any): number | null {\n  return (\n    trackPoint.extensions?.[0]?.[\"gpxtpx:TrackPointExtension\"]?.[0]?.[\n      \"gpxtpx:cad\"\n    ] ?? null\n  );\n}\n\nfunction getCoordinateFromTrackPoint(\n  trackPoint: any\n): [latitude: number, longitude: number] {\n  return [trackPoint.lat, trackPoint.lon];\n}\n\nfunction getPowerFromTrackPoint(trackPoint: any): number | null {\n  return trackPoint.extensions?.[0]?.power ?? null;\n}\n\nfunction getElevationFromTrackPoint(trackPoint: any): number | null {\n  return trackPoint.ele ?? null;\n}\n","import { Button } from \"@mui/material\";\nimport { ChangeEvent, useRef } from \"react\";\nimport styles from \"./LoadButton.module.scss\";\nimport { loadGPXFile } from \"./services/loaders/GPXLoader\";\nimport { GPXData } from \"./types\";\n\ninterface Props {\n  addGPXData: (data: GPXData) => void;\n}\n\nexport function LoadButton({ addGPXData }: Props) {\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  const handleFileChange = async (event: ChangeEvent<HTMLInputElement>) => {\n    if (!event.target.files) {\n      return;\n    }\n\n    for (let i = 0; i < event.target.files.length; i++) {\n      try {\n        const gpxData = await parseFile(event.target.files[i]);\n        addGPXData(gpxData);\n      } catch (e) {\n        console.error(e);\n      }\n    }\n  };\n\n  const handleButtonClick = () => {\n    if (!inputRef.current) {\n      return;\n    }\n    inputRef.current.value = \"\";\n    inputRef.current.click();\n  };\n\n  return (\n    <>\n      <input\n        type=\"file\"\n        accept=\".gpx\"\n        ref={inputRef}\n        onChange={handleFileChange}\n        className={styles.Input}\n      />\n      <Button variant=\"contained\" onClick={handleButtonClick}>\n        Load GPX\n      </Button>\n    </>\n  );\n}\n\nasync function parseFile(file: File): Promise<GPXData> {\n  if (!file.name.endsWith(\".gpx\")) {\n    throw new Error(\"Unsupported file type\");\n  }\n\n  return await loadGPXFile(file);\n}\n","import { Button } from \"@mui/material\";\nimport formatISO from \"date-fns/formatISO\";\nimport { sortBy, uniq } from \"lodash\";\nimport builder from \"xmlbuilder\";\nimport { GPXData } from \"./types\";\nimport FileSaver from \"file-saver\";\nimport slugify from \"slugify\";\n\ninterface Props {\n  data: GPXData;\n}\n\nexport function SaveButton({ data }: Props) {\n  const handleClick = () => {\n    const fileData = createXML(data);\n    FileSaver.saveAs(\n      new Blob([fileData], { type: \"text/xml\" }),\n      `${slugify(data.name || \"export\")}.gpx`\n    );\n  };\n\n  return (\n    <Button variant=\"contained\" onClick={handleClick}>\n      Save\n    </Button>\n  );\n}\n\nfunction createXML({\n  name,\n  type,\n  coordinate,\n  cadence,\n  elevation,\n  heartrate,\n  power,\n}: GPXData): string {\n  const timestamps = sortBy(\n    uniq(\n      [\n        coordinate,\n        ...(cadence ? [cadence] : []),\n        ...(elevation ? [elevation] : []),\n        ...(heartrate ? [heartrate] : []),\n        ...(power ? [power] : []),\n      ].flatMap((stream) => stream.data.map((d) => d.timestamp))\n    )\n  );\n  const firstTimestamp = Math.min(...timestamps);\n\n  const obj = {\n    gpx: {\n      \"@creator\": \"GPX Juggler\",\n      \"@xmlns\": \"http://www.topografix.com/GPX/1/1\",\n      \"@version\": \"1.1\",\n      \"xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n      \"@xsi:schemaLocation\": [\n        \"http://www.topografix.com/GPX/1/1\",\n        \"http://www.topografix.com/GPX/1/1/gpx.xsd http://www.garmin.com/xmlschemas/GpxExtensions/v3\",\n        \"http://www.garmin.com/xmlschemas/GpxExtensionsv3.xsd\",\n        \"http://www.garmin.com/xmlschemas/TrackPointExtension/v1\",\n        \"http://www.garmin.com/xmlschemas/TrackPointExtensionv1.xsd\",\n      ].join(\" \"),\n      metadata: {\n        time: { \"#text\": formatISO(firstTimestamp * 1_000) },\n      },\n      trk: {\n        name: { \"#text\": name },\n        type: { \"#text\": type },\n      },\n      trkseg: {\n        trkpt: timestamps.map((timestamp) => ({\n          ...(coordinate.data.find((d) => d.timestamp === timestamp)\n            ? {\n                \"@lat\": coordinate.data.find((d) => d.timestamp === timestamp)!\n                  .value[0],\n                \"@lon\": coordinate.data.find((d) => d.timestamp === timestamp)!\n                  .value[1],\n              }\n            : {}),\n          time: { \"#text\": formatISO(timestamp * 1_000) },\n          ...(elevation?.data.find((d) => d.timestamp === timestamp)\n            ? {\n                ele: {\n                  \"#text\": elevation.data.find(\n                    (d) => d.timestamp === timestamp\n                  )!.value,\n                },\n              }\n            : {}),\n          extensions: {\n            ...(power?.data.find((d) => d.timestamp === timestamp)\n              ? {\n                  power: {\n                    \"#text\": power.data.find((d) => d.timestamp === timestamp)!\n                      .value,\n                  },\n                }\n              : {}),\n\n            \"gpxtpx:TrackPointExtension\": {\n              ...(heartrate?.data.find((d) => d.timestamp === timestamp)\n                ? {\n                    \"gpxtpx:hr\": {\n                      \"#text\": heartrate.data.find(\n                        (d) => d.timestamp === timestamp\n                      )!.value,\n                    },\n                  }\n                : {}),\n\n              ...(cadence?.data.find((d) => d.timestamp === timestamp)\n                ? {\n                    \"gpxtpx:cad\": {\n                      \"#text\": cadence.data.find(\n                        (d) => d.timestamp === timestamp\n                      )!.value,\n                    },\n                  }\n                : {}),\n            },\n          },\n        })),\n      },\n    },\n  };\n  return builder.create(obj).end({ pretty: true });\n}\n","import { AppBar, Container, Toolbar, Typography } from \"@mui/material\";\nimport React, { useCallback, useState } from \"react\";\nimport { Editor } from \"./Editor\";\nimport { LoadButton } from \"./LoadButton\";\nimport { SaveButton } from \"./SaveButton\";\nimport { GPXData } from \"./types\";\n\nexport function App() {\n  const [gpxData, setGPXData] = useState<GPXData[]>([]);\n\n  const addGPXData = useCallback((data: GPXData) => {\n    setGPXData((prevData) => [...prevData, data]);\n  }, []);\n\n  return (\n    <>\n      <AppBar position=\"static\" sx={{ mb: 1 }}>\n        <Toolbar>\n          <Container>\n            <Typography variant=\"h6\">GPX Juggler</Typography>\n          </Container>\n        </Toolbar>\n      </AppBar>\n      <Container>\n        <LoadButton addGPXData={addGPXData} />\n        <SaveButton\n          data={{\n            name: \"Test\",\n            type: 5,\n            coordinate: {\n              type: \"coordinate\",\n              data: [\n                {\n                  timestamp: 0,\n                  value: [0, 0],\n                },\n              ],\n            },\n          }}\n        />\n        {gpxData.length > 0 && <Editor gpxData={gpxData} />}\n      </Container>\n    </>\n  );\n}\n","import CssBaseline from \"@mui/material/CssBaseline\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { App } from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <CssBaseline />\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}